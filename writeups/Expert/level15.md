# Level 15 Writeup — 多凭证一请求的防护缺陷

## 关卡目标
- 通过一次请求在 `password` 字段中提交多个候选密码，命中其一即可成功登录。
- 观察到后端对“尝试次数”的统计基于每请求而非每凭证，绕过常见的爆破防护。

## 场景概览
- 登录入口：`Expert/level15/login.html`
- 账号页：`Expert/level15/account.php`
- 登录后端：`Expert/level15/login.php`
- 用户数据：`Expert/level15/users.json`
- 尝试计数：`Expert/level15/rate.json`（运行中生成）

## 核心缺陷
- 解析器接受 `password` 为字符串或数组。
- 当 `password` 为数组时，后端遍历候选密码并逐一比对，只要命中即登录成功。
- 防爆破计数按“每个请求”递增，导致一次请求尝试多个密码只记一次。

## 攻击步骤
1. 正常登录探测
   - 在 `login.html` 直接提交单一密码，确认基础行为（成功将 302 跳转到 `account.php`）。
2. 构造数组密码
   - 使用抓包或页面提供的 JSON 提交入口，将 `password` 从字符串改为数组：
     ```json
     {
       "username": "carlos",
       "password": ["123456", "password", "qwerty"]
     }
     ```
   - 只要其中任意一项匹配服务端存储（如 `qwerty`），本次请求就会登录成功。
3. 成功判断
   - 观察响应 `302` 状态与 `Location: account.php` 头部；或通过页面跳转/账户页的用户名显示来确认。

## 验证点与证据
- `Expert/level15/login.php` 中对 `password` 类型的判断与数组遍历逻辑是缺陷根因。
- `rate.json` 的尝试次数仅以请求维度累加，不体现每个候选密码的独立尝试。

## 修复建议
- 输入归一化：严格限定 `password` 为字符串类型；拒绝数组或嵌套结构。
- 计数维度重构：将防爆破计数从“每请求”改为“每凭证/每用户名”维度；数组内每项均应计数。
- 统一解析：前后端统一数据模型与解析器，避免隐式类型分支导致绕过。
- 安全速率限制：引入验证码/滑块、IP 与设备指纹的综合限流与风险评估。

## 练习提示（教学角度）
- 真实系统中，允许数组/对象出现在原本应为标量的字段是一个常见易错点。
- 防护逻辑必须匹配攻击面维度（凭证级别），而不是仅按请求计数。

---
作者建议：在渗透测试中优先尝试将关键字段改为数组或对象，并测试服务端是否接受并产生逻辑偏差；同时结合重定向、Cookie 设置等副作用来判定行为差异。